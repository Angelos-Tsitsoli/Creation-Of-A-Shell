A.M : 1115202000200
Ονοματεπώνυμο : Άγγελος Τσιτσόλη

/////////////////////////////////////Γενικά για τρέξιμο και διαδικαστικά//////////////////////////////////////////////
*Σημείωση:Πολλές ιδέες πάρθηκαν απο τις διαφάνειες του μαθήματος , συγκεκριμένα τις διαλέξεις: lecture13 και lecture10 . Συγκεκριμένα απο τις δύο αυτές διαλέξεις απο το τελευταίο παράδειγμα της κάθε μιας.
*Επίσης για τα bash scripts έλεγξα τις διαφάνειες για πράγματα όπως τους ελέγχους τον ορισμάτων .
*Επίσης οι δομές που διάλεξα τα hash tables διάβασε τις διαφάνεις του κύριου κουμπαράκη στο μάθημα των δομών δεδομένων συγκεκριμένα την διαφάνεια Κατακερματισμός απο το site του.
**** Σημαντικό για τα bash script χρησιμοποίησα την uniq (γνωρίζω ότι δεν υπάρχει στις διαφάνειες) αλλά ψάχνωντας τρόπο να εκαθαρίσω τα διπλότυπα έπεσα πάνω της και συγκεκριμένα εδώ ώστε να καταλάβω την χρήση της https://www.geeksforgeeks.org/uniq-command-in-linux-with-examples/ . Η uniq χρησιμοποιήθηκε για να μην χρειαστεί να κάνω iterate συνεχώς το αρχείο και αν το κάνω update και μετά ότι λειτουργία χρειαζόταν διότι για πολλές ψήφους έπαιρνε πολύ χρόνο σε προηγούμενο κώδικα που έγραψα πριν φτάσω σαυτόν.

Τρέξιμο άσκησης: 
1)Compile : make
2)Καθαρισμός αρχείων μέσω του makefile για νέα make: make clean , make clean2
3)Τρέξιμο : Σημείωση*** -> για κάποιο λόγο το makefile όταν στέλνω το σήμα το σταματάει το πρόγραμμα και δεν λειτουργεί όπως το έχω φτιάξει  οπότε ενώ τα κάνω compile με την make για τον poller τo τρέχω με  π.χ.: ./poller 5679 8 16 pollLog3.txt pollStats3.txt . Ο pollerSwayer τρέχει και με make run2 αλλά για κάθε περίπτωση χρησιμοποιώ και αυτήν την εντολή  ./pollSwayer localhost 5679 inputFile.txt . Βάζω το compile του pollSwayer για κάθε περίπτωση gcc -o pollSwayer pollSwayer.c -lpthread.

ΠΟλύ σημαντικό επίσης -> έχω φτιάξει ένα hash table το οποίο είναι στατικό οπότε στον poller αν θέλουμε να βάλουμε πολλές ψήφους π.χ 10000 τότε να αλλάξετε στο "#define SIZE" τον αριθμό για τον χώρο , ανα΄λογα με τον αριθμό των ψήφων που θα μπούν . Για αρχή έβαλα 90.  
//////////////////////////////////////////////////////////////////////////////////////////////////////



Makefile:
Για το compile των αρχείων μπορούμε να εκτελέσουμε την εντολή make. Για να τρέξουμε το poll αρχείο τότε χρησιμοποιείται η εντολή make run, αντίστοιχα make run2 για το pollSwayer.
Για να σβήσουμε τα εκτελέσιμα τους γράφουμε make clean για το poll και make clean2 για το pollSwayer.
Στα πεδία ARGS και ARGS2 μπορούμε να αλλάξουμε τις παραμέτρους που δίνουμε σαν ορίσματα αρχικά για να τρέξουμε τα προγράμματα.


structures.h:
Το αρχείο αυτό διαθέτει συναρτήσεις που χρησιμοποιούνται όσο να αφορά την δομή του Hash table.

poller_interface.h:
Το αρχείο αυτό διαθέτει κυρίως τις συναρτήσεις που χρησιμοποιούνται για να γίνει επικοινωνία μεταξύ του server και των clients.
Η συνάρτηση Rseting αυτό που θα κάνει είναι να διαγράψει κάθε χαρακτήρα που έχει εκείνη την στιγμή ο πίνακας που δίνεται σαν όρισμα και να μετακινείσαι το σύμβιλο '\0' μερικές θέσεις πιο πριν ώστεν α χρησιμοποιηθεί πάλι ξανά ο πίνακας χαρακτήρων ως καινούργιος. 


poller.c:

**Master thread θεώρησα την Main μου κανονικά , δεν έφτιαξα δηλαδή άλλο thread.

Δομές δεδομένων που χρησιμοποιήθηκαν:
Οι δομές αυτές κάνουν double hashing για να είναι πιο γρήγορες .
Χρησιμοποιήθηκε η δομή Hash table τύπου Open Address .  Μία δομή τέτοιου τύπου χρησιμοποιήθηκε για την αποθήκευση των ονομάτων και ψήφων των ψηφοφόρων . Επίσης χρησιμοποιήθηκε άλλη μια τέτοια δομή για την αποθήκευση των αποτελεσμάτων των ψήφων κάθε κόμματος.
Επίσης χρησιμοποιήθηκε μια δομή τύπου pool όπως στο τελευταίο παράδειγμα της διάλεξης 13 στο παράδειγμα consumer producer. Ουσιαστικά το σκεπτικό της δομής αυτής είναι ένα κυκλικό buffer το οποίο θα έχει μία αρχή και ένα τέλος απο τα οποία ο consumer θα παίρνει απο αυτήν στοιχεία απο την αρχή , ενώ ο producer απο το τέλος. Θα ανανεώνεται κάθε φορά ο μετρητής στοιχείων μέσα στο buffer και η δομή πυο θα κρατιούνται τα στοιχεία θα είναι ένα απλός πίνακας. Θα εξηγηθεί και στην συνέχεια. 
Τέλος ένα struct που χρησιμοποιήθηκε είναι το name_surname_politicalparty το οποίο απλώς χρειάστηκε για να αποθηκεύω στοιχεία απο την ψήφο που διαβάζει κάθε φορά ο server και να τα κρατάει προσωρινά , ώστε να τα αναθέσει μέσω αυτής της δομής στις δομές των Hash tables.

Mutex και condition variables:
Χρησιμοποιήθηκε ένα mutex και δύο condition variables .Το mutex χρησιμοποιήθηκε προκειμένου να χρησιμοποιηθούν χωρίς πρόβλημα συγχρονισμού δομές , οι οποίες είναι κοινές στο πρόγραμμα.Επίσης το mutex χρησιμοποιήθηκε για την χρήση των condition variables. Συγκεκριμένασ τα condition variables έχουν ως ρόλο την πάυση της λειτουργίας κάποιου νήματος εργάτη και την επαναλειτουργία του . Για να πραγματοποιηιούν οι λειτουργίες αυτές απαιτείται και κάποιο mutex.  

Read και write (making_sure_write_sends), (making_sure_read):
Έχω δημιουργήσει αρκετές μικρές βοηθητικές συναρτήσεις.
Οι συναρτήσεις αυτές χρησιμοποιούνται για να διαβάζουμε και να γράφουμε δεδομένα μεταξύ του server και του client.
Η συνάρτηση making_sure_write_sends θα στείλει πρώτα το πόσα bytes εμπρόκειτο να είναι το μήνυμα που θα στείλει , και στην συνέχεια θα στέιλει το μήνυμα.
Ομοίως η making_sure_read πρώτα θα διαβάζει το μέγεθος του μηνύματος που εμπρόκειτο να διαβάσει και μετά θα διαβάσει το μήνυμα.

Provider:
Η συνάρτηση αυτή θα κληθεί απο την main κάθε φορά που έγινε δεκτή μία σύνδεση και θα τοποθετήσουμε ένα file descriptor μέσα στο buffer.
Αυτό που θα κάνει είναι απλώς να καλέσει την Put η οποία θα κάνει την ανάλογη δουλειά.

Put:
H συνάρτηση αυτή θα κληθεί απο την Provider . Ουσιαστικά θα ελέγξει αν ο buffer είναι γεμάτος . Σε περίπτωση που είναι τότε θα πρέπει να περιμένει μέχρι να αποδεσμευτεί κάποιο file descriptor μέσα του .
Επομένως σε περίπτωση που δεν είναι γεμάτος , θα προσθέσουμε έναν ακόμα file descriptor.
Σημειώνουμε ότι επειδή χρησιμοποιείται μια κοινή δομή ο buffer τότε θα κάνουμε αρχικά lock το Mutex και όταν τελειώσουμε την επεξεργασία του Buffer unlock.
Τέλος θα κάνουμε μέσω του con_v_not_empty ώστε ένα νήμα εργάτης να μπορεί να συνεχίσει. Αυτό το σήμα ουσιαστικά θα "ξυπνήσει" ένα νήμα εργάτη.


Get:
H συνάρτηση αυτή θα κληθεί απο την Purchaser ώστε να παρθεί ένας file descriptor απο τον buffer. Για να γίνεια αυτό κάνουμε wait το mutex ώστε να μην έχει κανείς πρόσβαση στο Buffer έπειτα ελέγχουμε αν είναι άδειος . Σε περίπτωση που είναι τ΄τοε θα περιμένει το νήμα , αλλιώς θα πάρουμε τον file descriptor και θα ανανεώσουμε τον μετρητή . Στο τέλος μέσω του con_v_not_full θα δώσουμε σήμα ότι δεν είναι γεμάτο το buffer διότι μόλις πήραμε ένα στοιχείο του .
Η συνάρτηση αυτή θα επιστρέψει τον file descriptor που μόλις πήρε .


Purchaser:
Η συνάρτηση αυτή θα κληθεί κατά την δημιουργία ενός νήματος θα αποτελέσει δηλαδή start function κατά την δημιουργία του νήματος.
Αυτό που θα κάνει είναι να δημιουργήσει 3 πίνακες από χαρακτήρες, οι οποίοι θα διαθέτουν το κατάλληλο μήνυμα που θα σταλεί κάθε φορά. Στη συνέχεια, θα δημιουργήσει 2 πίνακες χαρακτήρων για τους οποίους θα δεσμεύσουμε χώρο και θα τους χρησιμοποιήσουμε για να αποθηκεύουμε τα μηνύματα που στέλνει ο πελάτης στον εξυπηρετητή. Θα δεσμεύσουμε χώρο για τη δομή nspp, η οποία θα αποθηκεύει το όνομα, το επίθετο και την ψήφο του ψηφοφόρου που ψήφισε ένα κόμμα. Καλείται η συνάρτηση Get, η οποία θα επιστρέψει τον file descriptor του socket με το οποίο θα επικοινωνήσουμε με τον πελάτη γράφοντας και διαβάζοντας μηνύματα. Στη συνέχεια ακολουθεί η εξής αλληλουχία επικοινωνίας:
Στέλνουμε το μήνυμα "SEND VOTE PLEASE".
Διαβάζουμε την ψήφο του ψηφοφόρου.
Καλώντας τη συνάρτηση Assigning, αποθηκεύουμε στη δομή nspp το όνομα και το επίθετο του ψηφοφόρου.
Στη συνέχεια, κλειδώνουμε το mutex ξ προκειμένου να μην χρησιμοποιήσει κάποιος άλλος τη δομή του hash table, και μέσω αυτής ψάχνουμε για το όνομα του ψηφοφόρου. Μόλις τελειώσουμε, ξεκλειδώνουμε το mutex.
Σε περίπτωση που ο αριθμός που επιστρέψει αυτή η αναζήτηση είναι ίσος με -1, τότε στέλνουμε το μήνυμα στον πελάτη να μας στείλει το κόμμα που ψήφισε.
Όταν διαβάσουμε και το κόμμα που ψήφισε ο ψηφοφόρος, το αναθέτουμε στη δομή nspp.
Τέλος, στέλνουμε το μήνυμα επιβεβαίωσης της ψήφου για ένα συγκεκριμένο πολιτικό κόμμα. Μόλις στείλουμε και το μήνυμα επιβεβαίωσης, εισάγουμε στον πίνακα (table) τις πληροφορίες του ψηφοφόρου που μόλις ψήφισε και κλείνουμε το socket επικοινωνίας με τον πελάτη.
Σε περίπτωση που ο αριθμός που επιστραφεί είναι διάφορος του -1, τότε απλώς στέλνουμε το μήνυμα στον πελάτη ότι ο ψηφοφόρος αυτός έχει ήδη ψηφίσει και όταν κλείσουμε το socket επικοινωνίας με τον πελάτη.
Όλη αυτή η διαδικασία γίνεται μέσα σε ένα βρόχο προκειμένου το νήμα να μην 'πεθάνει' μετά την εκχώρηση ενός ψήφου, αλλά να περιμένει για την επόμενη φορά που θα κληθεί το συγκεκριμένο μήνυμα χωρίς κάποια ψήφο. Σε περίπτωση που ανιχνευθεί κάποιο σήμα παρεμβολής, τότε αυτό θα σημαίνει έξοδο του νήματος, δηλαδή θα βγούμε από τον βρόχο και θα εκτελεσθεί η συνάρτηση pthread_exit.


Η συνάρτηση main αυτό που κάνει είναι το εξής. 
Αρχικά τοποθετεί σε μεταβλητές τα ορίσματα που της δίνουμε από το τερματικό. 
Στη μεταβλητή size αναθέτουμε την τιμή του ορίσματος buffer size που πήραμε από το τερματικό.
Ουσιαστικά η μεταβλητή size είναι μια στατική μεταβλητή την οποία θα χρησιμοποιήσουν οι άλλες συναρτήσεις που θα κληθούν στη συνέχεια , με αυτό τον τρόπο δηλαδή κάθε συνάρτηση θα έχει πρόσβαση στο πόσο μεγάλο είναι το μπάφερ που θα χρησιμοποιήσουμε κάνουμε αρχικοποίηση του hash table  που θα χρησιμοποιήσουμε για 
την εκχώρηση πληροφοριών ενός ψηφοφόρου  όπως επίσης και την αρχικοποίηση της άλλες δομής που θα χρησιμοποιήσουμε γιατί εκχώρηση των ψήφων των πολιτικών κομμάτων. Μέσω της inserting for parties  αρχικό πιούμε τη δομή που θα χρησιμοποιήσουμε για την εκχώρηση των ψήφων των πολιτικών κομμάτων . Έπειτα αρχικό ποιούμε το mutex  και τα 2 condition variables. Όπως και το μπάφερ που θα χρησιμοποιήσουν στη συνέχεια. Δημιουργείται είναι ένα σοκετ μέσω της creating_socket  το οποίο θα αποτελέσει endpoint μέσω του οποίου θα γίνει η πρώτη επαφή του server με τους πελάτες .  Μέσω της συνάρτησης binding θα γίνει αντιστοίχιση της διεύθυνσης που πήραμε με 
το συγκεκριμένο φτιάξαμε. Μέσω της συνάρτησης listening ο εξυπηρετητής  θα μπορέσει να ακούει οποιοδήποτε αίτημα από πελάτη του έρθει . Στη συνέχεια δημιουργούμε ,  τόσα νήματα όσα  ζητηθούν από τις παραμέτρους. Τα  νήματα αυτά κατά τη δημιουργία τους δέχονται σαν συνάρτηση έναρξης την Purchaser. Ακολουθεί ένας βρόγχος , μέσα στον οποίο ο εξυπηρετητής θα δέχεται αιτήματα από πελάτες  και θα καλεί τη συνάρτηση Providerf μέσω της οποίας θα γίνουν οι κατάλληλες ενέργειες . Όταν κάποιος σήμα προκαλέσει το σταματημό αυτού του βρόχου τότε μέσω της συνάρτησης pthread_join  θα περιμένουμε όποιο τυχόν νήμα εκτελείται θα γίνουν οι κατάλληλες καταστροφές , θα κλείσουμε την επικοινωνία μεταξύ του εξυπηρετητή και του 
πελάτη και θα απελευθερώσουμε οποιοδήποτε δεσμευμένο χώρο.


Assigning:
H  συνάρτηση αυτή αυτό που θα κάνει είναι να διαβάζει το μήνυμα που θα της δώσουμε 
και να δίνει κάθε φορά στη δομή nspp τις κατάλληλες πληροφορίες. 
Συγκεκριμένα , αν το a_case έχει την τιμή μηδέν τότε θα δώσουμε στη δομή μας το όνομα και το
επίθετο του ψηφοφόρου που μόλις ψήφισε. Σε περίπτωση που η a_case έχει την τιμή 1 θα δώσουμε
στη δομή μας το πολιτικό, που ψήφισε ο ψηφοφόρος .



pollSwayer:
Διαθέτει αρχικά οριμένες μεταβλητές οι οποίες θα είναι global προκειμένου να μπορεί να γίνει η αξιοοποίηση των μεταβλητών αυτών και αππ την συνάρτηση func και απο την main .

Οι συναρτήσεις υπεύθυνες για την κλήση της write και της read είναι ίδιες και εδώ .

main:
Εδώ ουσιαστικά θα ανοίξουμε το αρχείο που θα δωθεί μέσω των παραμέτρων , έτσι ώστε να διαβάσουμε τα περιεχόμενα του.
Μέσω της συνάρτησης fgetc θα διαβάζουμε κάθε φορά χαρακτήρα χαρακτήρα κάθε γραμμή του αρχείου.
Ουσιαστικά θα διαβάζουμε ένα αρχείο με ονόματα , επίθετα και πολιτικά κόμματα. 
Μόλις διαβάσουμε απο μια γραμμή την πρώτη στήλη τότε την βάζουμε στον πίνακα column1 που θα κρατάει κάθε φορά κάποιο όνομα ώστε να το στείλει .
Έπειτα μόις διαβαστεί το σύμβολο space οι χαρακτήρες που ακολουθούν θα μπούν στον πίνακα column2 ο οποόιος κάθε φορά θα κρατάει το επίθετο της γραμμής που διαβάζεις.
Η δεύτερη φορά που θα εμφανιστεί το σύμβολο του space τότε οι χαρακτήρες θα δωθούν στον πίνακα column3 ο οποίος θα κρατάει το πολιτικό κόμμα που ψηφίστηκε στην συγκεκριμένη γραμμή.
όταν εμφανιστεί το σύμβολο '\n' τότε θα δημιουργηθεί ένα σοκετ για την επικοινωνία του εξυπηρετητή με τον πελάτη . Έπειτα θα δημιουργηθεί ένα νήμα το οποίο θα έχει ως συνάρτηση έναρξης την συνάρτηση func η οποία θα κάνεις τα παρακάτω εξής πράγματα.


func:
Αρχικά θα γίνει μέσω της connect η σύνδεση με τον εξυπηρετητή. Στην συνέχεια θα δώσουμε στον πίνακα store το όνομα και το επίθετο του ψηφοφόρου. Έπειτα θα γίνουν τα εξής :
Θα διαβάσουμε το μήνυμα απο τον εξυπηρετητή για να στείλουμε όνομα και επόθετο.
Στέλνουμε όνομα και επίθετο.
Διαβάζουμε το μήνυμα αν θα πρέπει να στέιλουμε το κόμμα που ψηφίστηκε.
Αν θα πρέπει να στείλουμε το πολιτικό κόμμα τότε θα το στείλουμε κανονικά και θα διαβάσουμε το τελικό μήνυμα κατοχύρωσης της ψήφου.
Έπειτα θα ελευθερώσουμε κάθε χώρο που δεσμευτήκαμε.
Θα κλείσουμε το αρχείο με το συγκεκριμένο file descriptor .
Θα κάνουμε έξοδο απο το νήμα και θα επιστρέψουμε στο σημείο της main που δημιουργήθηκε το νήμα , για να συνεχίσουμε με τις υπόλοιπες ψήφους.

Σήματα :
Όσον αφορά το control C όταν το πατάω δημιουργήσει μια μεταβλητή sigaction της οποίας τον handler τον έχω ορίσει να "δείχνει" ουσιαστικά στην συνάρτηση που έχω ορίσει ώστε να διαχειρίζεται τα σήματα. Οπότε κάθε φορά που καλεστεί το σήμα το flag που έχω ορίσει θα γίνει set στην τιμή 1 οπότε οι while βρόγχοι θα σταματήσουν , παράλληλα θα γίνει "fail" η συνάρτηση accept και το πρόγραμμα θα κάνει exit ομαλά.

Bash scripts:
create_input.sh:
Η κεντρική ιδέα του : Kάνω αρχικά τους κατάλληλους ελέγχους γεμίζω στην συνέχεια ένα πίνακα με γράμματα και παίρνω κάθε φορά τυχαία γράμματα ώστε να φτιάξω νέες λέξεις για όνομα και επίθετο και επιλέγω τυχαία ένα κόμμα.

tallyVotes.sh:
Γίνονται οι έλεγχοι ύστερα κάνω ταξινόμηση για να υπάρχουν τα ονόματα το ένα κάτω απο το άλλο ώστε να μπορέσει η uniq να καταφέρει και να διαγράψει τα διπλότυπα (δεν λειτουργεί αλλιώς οι uniq). Στην συνέχεια προσθέτω ψήφους στον πίνακα με τους ψήφους.

