A.M : 1115202000200
Ονοματεπώνυμο : Άγγελος Τσιτσόλη

Compilaiton/Run:
Γράφουμε απλά make run για να τρέξει make clean για να σβήσουμε τα .ο που δημιουργήθηκαν , ενναλακτικά gcc -g -o mysh mysh.c input_reader.c structures.c  και ./mysh

***Σημείωση : τρέχωντας το πρόγραμμα μέσω του make run το CTRL Z δεν ανταποκρίνεται ενώ γράφοντας τις εντολές στο τέρμιναλ για να τρέξει το πρόγραμμα (gcc -g -o mysh mysh.c input_reader.c structures.c  και ./mysh) λειτουργεί όπως πρέπει .


ΠΟλλές ιδέες όσον αφορά την υλοποίηση του κελύφους πάρθηκαν απο το βιβλίο σελίδες 409 - 422 και 650-654. 


Εξήγηση του αρχείου structures.c και γενικότερα των επιλογών που επιλέχθηκαν για την υλοποίηση του history και του alias :

Γενικότερα οι δομές που χρησιμοποίησα ήταν μια απλά συνδεδεμένη λίστα με διαφορετικές μορφές . Ουσιαστικά η διαφορά των μορφών αυτών είναι ένα πραπάνω δεδομένο στο struct που αναφέρεται στο alias σε σχέση με το struct που αναφέρεται sto history.

History: 
Για το ιστορικό δημιούργησα μια απλά συνδεδεμένη λίστα η οποία θα διαθέτει την εντολή που γράφτηκε απο το πληκτρολόγιο , τον αριθμό που μπήκε στην λίστα η εντολή πχ μπήκε 1η,2η,3η.....
Κάθε εντολή που γράφουμε θα μπαίνει κατευθείαν στο ιστορικό εκτός αν είναι αριθμός σκέτος που θα αναφέρω πως χρησιμοποιείται και εκτός αν είναι το σύμβολο '^' ή το σύμβολο '\0', όλες οι άλλες εντολές θα μπούν κανονικά.
Κάθε φορά που γράφουμε στο πληκτρολόγιο μόνο το σύμβολο '^' ο parser καταλαβαίνει ότι θέλουμε να εκτυπώσουμε το ιστορικό μέχρι τώρα .
Κάθε φορά που γράφουμε έναν αριθμό μόνο σαν εντολή τότε θα εκτελεστεί η εντολή που έχει αυτόν τον αριθμό μέσα στο ιστορικό.
Κάθε φορά που εκτυπώνουμε το ιστορικό τότε η νεότερη εντολή που βάλαμε μέχρι τώρα βρίσκεται τελευταία δλδ έστω ότι βάλαμε την εντολή ls ως τελευταία στο κελυφός (τρίτη γενικότερα εντολή που βάλαμε )μας μέχρι τώρα τότε αν εκτυπώσουμε το ιστορικό θα έχουμε το εξής :

1.cat file.txt
2.cd folder 
3.ls  

Κάθε φορά που φτάνουμε τις 20 εντολές που εισάχθηκαν στο ιστορικό και βάζουμε καινούργια τότε διαγράφεται η παλιότερη εντολή που εισάχθηκε και μπαίνει η καινούργια ξεκινώντας απο την αρχή την αρίθμηση θα πάρει τον αριθμό 1 . Μετά την εικοστή εντολή ξεκινάει η αρίθμηση πάλι απο την αρχή.


Alias:
Για τα alias δημιούργησα μια απλά συνδεδεμένη λίστα η οποία θα αποθηκεύει σε κάθε κόμβο της κάθε φορά την εντολή που θέλω να έχει καινούργιο όνομα , την εντολή που άλλαξα και τον αριθμό εισαγωγής της σε σχέση με τις άλλες εντολές alias της απλά συνδεδεμένης λίστας .
Κάθε φορά που πληκτρολογώ το σύμβολο '@' ως εντολή τότε εκτυπώνονται όλα τα aliases που έχουν δημιουργηθεί εώς τώρα .
Σε περίπτωση πυο φτιάξω ένα alias τότε πληκτρολογώντας το όνομα του σαν εντολή μπορώ να το εκτελέσω .
Προκειμένου να διαγράψουμε ένα alias γράφουμε την αντίστοιχη εντολή και διαγράφεται το alias με το συγκεκριμένο όνομα.


mysh.c

Το αρχείο αυτό ουσιαστικά χρησιμοποιείται προκειμένου να παίρνουμε την εντολή απο το τερμιναλ και να την δίνουμε στην συνάρτηση Instruction_handler για περαιτέρω επεξεργασία της εντολής.
Αρχικά έχω την δημιουργία και την αρχικοποίηση μιας δομής που θα λειτουγεί ως ιστορικό του κέλυφους και μια δομής που θα αποθηκεύει τα aliases.

Στην συνέχεια έχω μια while που θα τρέχει συνεχώς η οποία θα λειτουργήσει ως prompt που θα δέχεται εντολές που θα δίνουμε εμείς απο το τερμιναλ.
Χρησιμοποιώ την fgets , διότι μέσω αυτής μπορούμε να περάσουμε στο κέλυφος ολόκληρα strings . 
Γενικότερα αποφάσισα να δημιουργήσω έναν στατικό πίνακα (input) μέσα στο οποίο θα δώσω μέσω της fgets ολόκληρη την εντολή και θα τον περνάω στις συναρτήσεις που χρειάζεται .
Αποφάσισα σε κάθε εντολή να βγάζω στο τέλoς της το σύμβολο '\n' και να βάζω στην θέση του το '\0' , ώστε αυτό να αποδεικνύει το τέλος της εντολής.
Κάθε φορά που βάζω σαν εντολή μόνο έναν αρ
ιθμό τότε ψάχνω στο ιστορικό να βρώ την εντολή και δίνω αυτήν στο input (το οποίο όπως είπα θα ρατάει όλη την εντολή και θα την δίνει στην συνάρτηση Instruction handler αρχικά για την περαιτέρω ανάλυση της).
Κάθε φορά που πλητρολογώ στην fgets εντολή που προέκυψε απο alias , τότε ψάχνω στην δομή που κρατάω τα alias για την εντολή που αντικατέστησε ουσιαστικά η εντολή που έβαλα ως alias. Αν βρεθεί τοποθετείται στο input για περαιτέρω ανάλυση αργότερα.
Τελος η τελευταία while που έχω είναι για να εκτελείται συνεχώς η επεξεργασία της εντολής και η εκτέλεση της μέχρι να βρεθεί το enum THE_END που σημαίνει ότι διαβάστηκε όλη η εντολή ή το enum AM που σημαίνει ότι διαβάστηκε η εντολή που στο τέλος διαθέτει το σύμβολο & , δηλαδή εκτελείται στο παρασκήνιο ,ή όταν επιστρέφεται το enum HISTORY που σημαίνει ότι απλώς δώσαμε σαν εντολή το σύμβολο '^' ή τέλος όταν επιστρέφεται το enum ALIAS που σημαίνει ότι δώσαμε σαν εντολή το σύμβολο '@'. Τα δύο τελευταία σύμβολα απλά θέλουμε να εκτυπώσουν κάτι και όχι κάτι παραπάνω γιαυτό και οταν επιστρέφουν αυτά τα enums θέλουμε να τερματίσουν.
Καλείται η Instruction handler για την επεξεργασία και εκτέλεση της εντολής και τέλος η waitpid θα εκτελεσθεί μόνο σε περίπτωση που ο δεν έχουμε εντολή που περιέχει το σύμβολο & διότι θέλουμε να εκτελείται στο παρασκήνιο.


input_reader.c 

Οι σημαντικότερες συναρτήσεις στο αρχείο αυτό είναι η  συνάρτηση Reading και η συνάρτηση Instruction handler οι υπόλοιπες συναρτήσεις καλούνται απο αυτές τις δύο μεγάλες συναρτήσεις .

Συνάρτηση Reading:

Εμπρόκειτο να φτιάξουμε ένα κέλυφος επομένως είναι απαραίτητο να δημιουργηθεί μία συνάρτηση η οποία θα αποτελεί τον Parser μας , δηλαδή μια συνάρτηση η οποία θα σπάει σε κομμάτια την εντολή και κάθε κομμάτι θα το χαρακτηρίζεται με τη βοήθεια ενός 'λεξιλογίου' enum το οποίο περιέχει διάφορες ονομασίες για κάθε περίπτωση. Συγκεκριμένα:

1.TERM : για κάθε συμβολοσειρά γραμμάτων π.χ cat,sort.....
2.SEM :για το σύμβολο ';'
3.AM : για το σύμβολο '&'
4.VERT_BAR : για το σύμβολο '|'
5.LEFT_ARROW : για το σύμβολο '<'
6.RIGHT_ARROW : για το σύμβολο '>'
7.DOUBLE_RIGHT_ARROW : για το σύμβολο '>>'
8.THE_END : όταν τελειώσουν οι χαρακτήρες που διαβάζουμε δηλαδή δεν υπάροχουν άλλοι.
9.HISTORY : για οτ σύμβολο '^'
10.ALIAS : για το σύμβολο '@'
11.ERROR : για τυχόν λάθος που προκύψει

Κάθε φορά που αντιστοιχίζεται κάτι απο τα παραπάνω εκτός απο το ERROR τότε επιστρέφεται στον Instruction handler .

Eπομένως η συνάρτηση Instruction handler θα καλέσει την συνάρτηση Reading ώστε να χαρακτηρίστεί κάθε κομμάτι της εντολής που δώσαμε και να πράξει να χειριστεί κάθε όρο ανάλογα η συνάρτηση Instruction handler.
Kάθε φορά η Reading διαβάζει την εντολή που της δίνεται (το πρώτο όρισμα) ανά χαρακτήρα και αυξάνει τον αριθμό των χαρακτήρων που έχουμε διαβάσει απο την εντολή μέσω της last_position . Η last_position είναι μια μεταβλητή στατική που μας βοηθάει κάθε φορά που καλείται η συνάρτηση Reading να ξέρουμε που να συνεχίσουμε το διάβασμα.
Επίσης κάθε φορά που διαβάζουμε έναν χαρακτήρα δίνουμε στην μεταβλητή con σε τι κατάσταση βρισκόμαστε . Οι καταστάσεις είναι τρείς DEFAULT,WORD_READING,QUOTATION_WORDS.
Οι δύο τελευταίες καταστάσεις γνωρίζουν ότι διαβάζουν συμβολοσείρές οπότε αποθηκεύουν κάθε γράμμα για να δημιουργηθεί η τελική λέξη , σε αντίθεση με την πρώτη κατάσταση η οποία απλά διαβάζει χαρακτήρες δεν γνωρίζει ότι διαβάζει κάτι συγκεκριμένο πχ συμβολοσειρά.   

1.DEFAULT : Σαυτην την κατάσταση διαβάζουμε τους χαρακτήρες . Αν ο χαρακτήρας είναι κάποιος απο αυτούς '>','<','|',';','&','^','@'τότε θα επιστρέψει τον χαρακτηρισμό που του αναλογεί με βάση το enum αν διαβαστεί ' ' τότε απλά θα συνεχίσει. Σε περίπτωση που δεν διαβαστεί κάτι απο αυτά τότε θα πάμε στην default του switch που σημαίνει διαβάζουμε χαρακτήρες άρα η κατάσταση con θα αλλάξει σε WORD_READING. Σε περίπτωση που διαβαστεί '"' τότε ξέρουμε ότι πρόκειται να διαβαστείσυμβολοσειρά μέσα σε εισαγωγικά.
2.WORD_READING : Διαβάζουμε συμβολοσειρά και κάθε γράμμα το αποθηκεύουμε στο δεύτερο όρισμα της Reading μέχρι να πετύχουμε ένα σύμβολο διαφορετικό απο γράμμα ή και το space ' ' όπου αυτό σημαίνει ότι τελείωσε η διαδικασία αποθήκευσης των γραμμάτων για τον σχηματισμό λέξης . 
3.QUOTATION_WORDS : Διαβάζουμε συμβολοσειρά μέσα σε εισαγωγικά . Δεν διαφέρει απο την πάνω κατάσταση με τον ίδιο τρόπο θα αποθηκεύσουμε κάθε γράμμα απλώς στην κατάσταση αυτή ξεκινάμε με το σύμβολο '"' και μόλις ξαναπετύχουμε το σύμβολο '"' τότέ ξέρουμε ότι τελείωσε η διαδικασία αποθήκευσης και σχηματισμού της λέξης.

Όταν δεν πληρείται καμία απο τις περιπτώσεις καθώς διαβάζουμε κάθε γράμμα τότε απλώς επιστρέφουμε THE_END γιατί σημαίνει ότι τελειώσαμε το διάβασμα.

Συνάρτηση Instruction_handler:
Η συνάρτηση Instruction handler είναι υπεύθυνη για την συναρμολόγηση των κομματιών της εντολής μέσω των χαρακτηρισμών που είδαμε παραπάνω και εκτέλεσης εν τέλει της εντολής.
Καλούμε την συνάρτηση Reading η οποία θα μας επιστρέψει έναν απο τους χαρακτηρισμούς που περιγράψαμε παραπάνω και ανάλογα μ'αυτό που επέστρεψε πράττουμε αναλόγως .
Να σημειωθεί ότι στην περίπτωση που επιστραφεί ΤΕRM τότε μαζί μαυτόν το χαρακτηρισμό που επιστρέφεται η Reading γεμίζει και τον πίνακα με χαρακτήρες που δέχεται απο την Instruction_handler με την λέξη που διαβάστηκε , αυτή η λέξη θα δωθεί στον πίνακα argv ώστε να σχηματιστεί η εντολή.
Περιπτώσεις Instruction_handler:

TERM: Σε περίπτωση που προκύψει TERM απο την Reading τότε καλούμε την συνάρτηση  Filling_argv_and_wild_card_check προκειμένου να γεμίσουμε τον πίνακα argv με την λέξη και να ελέγξουμε μήπως προκύπτει περίπτωση με wild card δηλαδή αν έχουμε κάποιο σύμβολο '*' ή '?' μέσα στην λέξη ώστε να βρούμε κάθε αποτέλεσμα που μπορεί να προκύψει απο αυτό .

AM: Σε περίπτωση που προκύψει ΑΜ απο την Reading τότε απλώς βάζουμε τον αριθμό 1 στην μεταβλητή ampersand η οποία είναι στατική , λειτουργεί σαν flag δηλαδή , για να ξέρουμε αν η εντολή που δώθηκε πρέπει να εκτελεστεί στο παρασκήνιο.

SEM :Σε περίπτωση που προκύψει SEM απο την Reading τότε η συμπεριφορά που θέλουμε είναι απλώς να εκτελεστεί η εντολή με τα κομμάτια που καταγράφτηκαν μέχρι τώρα στην argv  . ΄Επειτα εφόσον βρεθεί ερωτηματικό να συνεχίζει να διαβάζει διότι θα υπάρχει και άλλη εντολή στην συνέχεια . Γενικότερα σε περίπτωση που βρεθεί το ερωτηματικό τότε εκτελείται η εντολή που έχει καταγραφεί μέχρι τώρα και συνεχίζεται το διάβασμα μέχρι να τελειώσει το διάβασμα και η εκτέλεση κάθε εντολής βρεθούμε δηλαδ΄γη σε κατάστασδη THE_END.

LEFT_ARROW: Σε περίπτωση που έχουμε ανακατέυθυνση προς την είσοδο τότε καλείται η συνάρτηση Redir_check προκειμένου να δούμε αν ο επόμενος χαρακτηρισμός που θα μας δώσει η Reading είναι τύπου TERM γιατί σε περίπτωση που δεν είναι τότε προκύπτει λάθος . Οπότε διαβάζεται και το επόμενο κομμάτι της εντολής αν είναι λέξη τότε συνεχίζουμε αν δεν είναι τότε βάζουμε την τιμή -5 να επιστραφεί ώστε να δείξει ότι υπάρχει λάθος.

RIGHT_ARROW: Σε περίπτωση που υπάρχει ανακατεύθυνση ως προς την έξοδο τότε και εδώ καλείται η Redir_check ομοίως με την LEFT_ARROW.

DOUBLE_RIGHT_ARROW: Σε περίπτωση που υπάρχει το σύμβολο '>>' τότε κάνουμε τον ίδιο έλεγχω με τις προηγούμενες δύο περιπτώσεις απλώς βάζουμε τον αριθμό 1 στο flag doub_right για να ξέρουμε ότι υπάρχει το σύμβολο '>>' στην εντολή που διαβάστηκε.

HISTORY: Αυτό σημαίνει ότι διαβάστηκε το σύμβολο '^' νωρίτερα οπότε απλώς να επιστραφεί δεν θέλουμε περαιτέρω επεξεργασία.

ALIAS:  Αυτό σημαίνει ότι διαβάστηκε το σύμβολο '@' νωρίτερα οπότε απλώς να επιστραφεί δεν θέλουμε περαιτέρω επεξεργασία.

THE_END: Γενικότερα σημαίνει ότι διαβάσαμε όλη την εντολή και ήρθε η ώρα να την εκτελέσουμε . Η εκτέλεση δηλαδή της εντολής θα γίνεται κάθε φορά για κάθε case = THE_END που πετυχένουμε. 

VERT_BAR: Αυτό σημαίνει ότι υπάρχει το σύμβολο '|' μέσα στην εντολή δηλαδή θα χρειαστεί η δημιουργία κάποιου pipe θα εξηγηθεί παρακάτω καλά.


Συνάρτηση Redirection :

Σε περίπτωση που έχουμε εντολή που πρέπει να εκτελεστεί στο παρασκήνιο και δεν έχει ανακατευθυνθεί η είσοδος της τότε ανακατευθύνουμε στο αρχείο /dev/null , ώστε να δωθεί άμεσο τέλος κατά την ανάγνωση. (απο βιβλίο σελίδα 420 η ιδέα)

H συνάρτηση αυτή χρησιμοποιείται ουσιαστικά για τυχόν ανακατευθύνσεις εισόδου ή και εξόδου . Δέχεται σαν ορίσματα τα ονόματα των των αρχείων στα οποία μπορεί να γίνει η ανακατεύθυνση και τους file descriptors τους , καθώς και μια μεταβλητή doub_right η οποία μας αναφέρει αν πρόκειται για το σύμβολο '>>'.
Σε περίπτωση που η input_file έχει χαρακτήρες μέσα της δηλαδή υπάρχει ένα αρχείο που θα πρέπει να γίνει η ανακατεύθυνση , τότε μέσω της χρήσης της open θα ανοίξουμε το αρχείο που βρίσκεται μαυτό το όνομα ή με το path αυτό με flag=O_RDONLY για να διαβάσουμε απλά το αρχείο. Η οποία μάλιστα θα επιστρέψει τον file descriptor .  Σαν mode βάζουμε τον αριθμό μηδέν. Σε περίπτωση που η the_in διαθέτει διαφορετικό αριθμό απο το μηδέν τότε θα αλλάξηει η είσοδος μέσω της dup2 και θα μεταφερθεί στο αρχείο πoυ της είπαμε αλλιώς δεν θα αλλάξει η είσοδος θα παραμείνει εκεί που ήταν αρχικά .
Σε περίπτωση που η the_in διαθέτει διαφορετικό file descriptor απο ότι το STDIN_FILENO τότε κλείνουμε το αρχείο που ανοίξαμε διότι η dup2 ανακατευθύνει την είσοδο οπότε το καινούργιο αρχείο θα είναι ανοιχτό , άρα ουσιαστικά δνε θέλουμε να είναι απο δύο μέρη ανοιχτό το file.
Σαν flags δεν χρειάζεται άλλο εκτός απο το O_RDONLY .

Σε περίπτωση που η output_file διαθέτει κάποιο όνομα ή μονοπάτι αρχείου τότε ακολουθούμε τα ίδια βήματα όπως παραπάνω . Ωστόσο τα flags θα είναι διαφορετικά , δηλαδή σε κάθε περίπτωση θα έχουμε O_WRONLY και O_CREAT δηλαδή να γράψουμε στο αρχείο και αν δεν υπάρχει να δημιουργηθεί . Ο κωδικός 0666 δίνει άδειες εγγραφης και ανάγνωσης σε owner,group,all other users.
Επίσης σε περίπτωση που έχουμε το σύμβολο '>>' τότε συμπεριλαμβάνουμε το φλαγκ O_APPEND ώστε να συμπληρώσει ότι χρειαστεί στο νέο αρχείο , ενώ αν δεν έχω τέτοιο σύμβολο τότε να προσθέσει το φλαγκ O_TRUNC για να γράψει απο την αρχή ότι θέλει δλαδή εν τέλει να δώσει καινούργιο περιεχόμενο στο αρχείο εξόδου.

Συνάρτηση Execution:
Στην συνάρτηση αυτή θα γίνει η εκτέλεση κάθε εντολής .
Θα ελέγξουμε αρχικά αν πρόκειται για την εντολή cd ή για εντολή που αφορά alias μέσω των συναρτήσεων Check_for_cd() και  Check_for_alias_commands() που έχουν διαφορετική εκτέλεση αλλιώς συνεχίζουμε με για την εκτέλεση της εντολής κανονονικά.
Προκειμένου να εκτελεστούν οι εντολές θα χρησιμοποιήσουμε την execvp οπότε είναι απαραίτητο να χρησιμοποιήσουμε φορκ.
Διεργασία παιδί:
Αν βρισκόμαστε στην διεργασία παιδί κλείνουμε απο το pipe το κομμάτι της εγγραφης , διότι δεν θα το χρειαστούμε.
Σε περίπτωση που δεν πρόκειται για εντολή παρασκηνίου τότε θα επιτρέψουμε απο τα σήματα να λειτουργήσουν όπως πρέπει .
Καλούμε την συνάρτηση Redirection γιαν α γίνουν οι κατάλληλες ανακατευθύνσεις αν χρειαστούν .
Εκτελούμε έπειτα την execvp.
Διεγασάι πατέρας :
Αν βρισκόμαστε στον πατέρα και έχουμε εντολή παρασκηνίου εκτυπώνουμε το pid.
Σε περίπτωση που είμαστε σε διεργασία που πρόκειται να διαβάσει απο το κομμάτι ανάγνωση του pipe κλείνουμε την είσοδο απο το γονέα , ενώ σε περίπτωση που μια διεργασία εμπρόκειτο να γράψει στο κομμάτι της εγγραφής του pipe τότε απο τον πατέρα θα κλείσουμε το pipe στο σημείο αυτό. (θα εξηγηθεί έπειτα αναλυτικά η λειτουργία των pipes)
Σε κάθε περίπτωση επιστρέφουμε το pid του παιδιού και μόνο σε περίπτωση που δεν έχουμε εντολή παρασκηνιού περιμένουμε μέσω της waitpid απο την αρχική κλήση της συνάρτησησς Instruction_handler.


Υλοποίηση των σωληνώσεων :
Υποθέτουμε ότι έχω μια εντολή τύπου cat file.txt | sort και δουλεύουμε μαυτήν για να εξηγήσουμε λίγο πως γίνεται η διαδικασία. H αυτή  θεωρείται σαν δύο εντολές διότι έχουμε την εντολή cat file.txt και την εντολή sort  εκατέρωθεν του '|'.
Η γενική ιδέα για την υλοποίηση των σωληνέωσεν είναι η εξής : διαβάζουμε το κομμάτια εντολής που δώθηκε και τα αποθηκεύουμε μέσω της συνάρτησης Instruction_handler μέχρι να πετύχουμε κάθε φορά το σύμβολο '|' μέσα στην εντολή όπου στην περίπτωση μας είναι το cat file.txt,  έπειτα καλούμε αναδρομικά την συνάρτηση Instruction_handler για να διαβάσουμε και να εκτελέσουμε πρώτα την δεύτερη εντολή sort στην περίπτωση μας όπου αυτήν την φορά δίνοντας την τιμή 1 ως όρισμα pipe_checking ώστε να δημιουργηθεί ο σωλήνας  σε αντίθεση με την πρώτη φορά που μπήκαμε κατά την οποία το όρισμα ipe_checking είχε τιμή 0 δηλαδή να μην δημιουργηθεί σωλήνας.
Επομένως διαβάζοντας την εντολή sort φτάνουμε στο τέλος διαβάσματος της δηλαδή σε '\0' οπότε και ξεκινάει η εκτέλεση της εντολής αυτής . Οπότε η κατάσταση του state δίνεται στην state2 (η κατάσταση ΤΗΕ_ΕND δηλαδή) ώστε έπειτα να επιστραφεί . Θα δημιουργηθεί ένας σωλήνας κατά τον οποίο το κομμάτι ανάγνωσης , ο file descriptor του θα επιστραφεί απο την συνάρτηση και θα δωθεί στην μεταβλητή in ενώ το κομμάτι εγγραφής θα δωθεί ως περιεχόμενο στην μταβλητή που δείχνει ο δέικτης pipe_des δηλαδή στην μεταβλητή out που δώθηκε ως όρισμα στην αναδρομική κλήση της Instruction_handler. Αυτό γίνεται , γιατί ουσιαστικά είμαστε στην δεύτερη εντολή και η δεύτερη εντολή θέλει να διαβάσει απο το κομμάτι εγγραφής του pipe οπότε εφόσον η πρώτη εντολή θα χρειαστεί να γράψει στο κομμάτι εγγραφής του pipe κρατάμε τονfile descriptor εγγραφής ώστε να δωθεί στην πρώτη εντολή για να γράψει , δεν τον κλείνουμε δηλαδή το κομμάτι του pipe αυτό μέχρι να το πάρει και η πρώτη εντολή (όταν γυρίσει δηλαδή η αναδρομή και εκτελεστεί η πρώτη εντολή) και να γράψει σαυτό.
Δηλαδή κάθε φορά φτιάχνουμε το σωλήνα δίνουμε στην δεύτερη εντολή το κομμάτι ανάγνωσης και το κλείνουμε ωστόσο κρατάμε το κομμάτι εγγραφής ανοιχτό για να γράψει η πρώτη εντολή και μόνο τότε το κλείνουμε .
Οπότε συνεχίζοντας είμαστε στην εκτέλεση της δεύτερης εντολής καλείται επομένως η συνάρτηση Execution μόλις εκτελεστεί η η fork , η διεργασία παιδί θα κλείσει αρχικά το κομμάτι του σωλήνα που αφορά την εγγραφή γιατί δεν θα το χρειαστεί έπειτα στην συνάρτηση Redirection θα κάνει ανακατέυθυνση της εισόδου και θα την κλείσει εφόσο νμέσω της dup2 δημιουργείται νέος file descriptor , οπότε θα επιστρέψει η Redirect kai ua ekteleste;i h execvp , απο την άλλη ο γονέας θα κλείσει το κομμάτι ανάγνωησς μόνο και θα επιστρέψει ηExecution . Στην συνέχεια θα επιστρέψει και η Instruction_handler  .
Οπότε θα δωθεί το THE_END στη state2 και θα εκτελεστεί η Execution . Θα εκτελεστεί η φορκ έπειτα μέσω της Redirection  θα γίνει ανακατέυθυνση για την έξοδο με το κομμάτι εγγραφής του σωλήνα και θα κλείσει το κομμάτι αυτό εφόσον η dup2 θα δημιουργήσει καινούργιο file descriptor , οπότε θα επιστρέψει απο την συνάρτηση και έπειτα θα εκτελεστεί η execvp , ο γονέας θα κλείσει το κομμάτι εξόδου , το κομμάτι εισόδου θα είναι stdin οπότε δεν θα κλείσει .Οπότε θα τελειώσει έτσι η σωλήνωση καθώς στο σημείο αυτό έχει κλείσει το κομμάτι ανάγνωσης απο παιδί και γονέα και έμεινε ανοιχτό το κομμάτι εγγραφής για να γράψει αυτη η εντολή που περιγράψαμε οπότε θα κελισει τώρα απο το παιδί και απο τον πατέρα , με αποτέλεσμα να τελειώνει η διαδικασία σωλήνωσης .


Γενικότερα τα ζητούμενα πως υλοποιούνται :

Βασική λειτουργία κελύφους εισαγωγής και κλήσης απλών εντολών και εκτύπωσης αποτελεσμάτων :
Σε περίπτωση που έχουμε μια απλή εντολή για παράδειγμα ls τότε αυτή θα δωθεί απο την Instruction_handler στην Reading , έπειτα η Reading θα την διαβάσει και θα επιστρέψει τον χαρακτηρισμό TERM οπότε θα αποθηκευτεί στον πίνακα argv η συμβολοσειρά ls και θα συνεχιστεί η while στην επόμενη κλήση της Reading θα διαβαστεί το σύμβολο '\0' που σημαίνει ότι τελείωσε το διάβασμα της εντολής οπότε θα επιστρέψει THE_END στην Instruction_handler άρα η συνάρτηση Instruction_handler θα προχωρήσει στην εκτέλση της συνάρτησης μέσω της Execution 

Ανακατευθύνσεις:
Κάθε φορά γράφουμε εντολές ανακατεύθυνσεις τότε αυτές στην ουσία διαυθετόυνται στην συνάρτησησ Redirection .

Για μονή ανακατεύθυνση :
Η συνάρτηση Reading θα επιστρέψει κάποια στιγμή τον χαρακτηρισμό RIGHT_ARROW ή LEFT_ARROW στην συνάρτηση Instruction_handler οπότε με την σειρά της η  Instruction_handler θα καλέσει την Redir_check για να τσεκάρει το επόμενο κομμάτι της εντολής αν είναι λέξη , γιατίο αν δεν είναι τότε θα υπάρξει λάθος . Οπότε σε περίπτωση που είναι τότε θακαλεστεί η Execution η οποία θα καλέσει πρλωτα την Redirection για να γίνουν οι ανακατευθύνσεις και έπειτα θα επιστρέψει όπου και θα εκτελεστεί η execvp. 

Για ανακατεύθυνση προσθήκης :
Θα γίνει ακριβώς η ίδια διαδικασία απλώς στην περίπτωση μας αυτή θα υπάρχει και μια μεταβλητή η οποία θα μας λέει ότι πρόκειταΙ για ανακατεύθυνση προσθήκης ώστε να αλλάξει το flag απο Ο_ΤRUNC ΣΕ Ο_APPEND στην Redirection.

Για ανακατεύθυνση διπλή :
Θα γίνει οι ίδια διαδικασία όπως στην μονή ανακατέυθυνση απλώς σε μια εντολή θ α γίνει περισσότερες απο μία ανακατευθύνσεις 


Σωληνώσεις εξηγήθηκαν παραπάνω .

Εντολές παρασκηνίου:
Ουσιαστικά για τις εντολές αυτού του τύπου το μόνο ζητούμενο είναι να μην περιμένουμε την διαδικασία παιδιού που θα δημιουργήσει η φορκ στην συνάρτηση Execution.
Αυτό πυο θα γίνει για τις εντολές αυτές είναι ότι η συνάρτηση θα επιστρέψει ΑΜ όταν δει το σύμβολο '&' οπότε η συνάρτηση Instruction_handler θα δώσει στην μεταβλητή ampersand την τιμή 1 , προκειμένου να ξέρουμε ότι πρόκειται για εντολή παρασκηνίου . Επομένως  συνάρτηση Execution θα ελέγξουμε αν η εντολή μας έχει να κάνει με εντολή background αν όχι τότε θα επιτρέψουμε κάθε σήμα αλλιώς δεν επιτρέπονται τα σήματα . Στην συνάρτηση Redirection σε περίπτωση που δεν έχει ανακατευθυνθεί η ροή εισόδου τότε θα την ανακατευθύνουμε στο αρχείο /dev/null το οποίο αυτό που κάνει είναι να διαγράφει το αποτέλεσμα , δηλαδή να μην εμφανίζεται στην οθόνη γιατί δεν μας ενδιαφέρει εφόσον είναι εντολή παρασκηνίου . Έτσι ουσιαστικά αποτρέπουμε μαυτόν τον τρόπο απορρίπτετε η έξοδος της εντολής και αποτρέπει απο το να γεμίσει η οθόνη . 
Ακόμα όταν επιστρέωουμε στο αρχείο mysh και τελειώσειη διαδικασία εκτέλεσης εντολής τότε στην συνέχεια η waitpid θα εκτελεστεί μόνο σε περίπτωση που έχουμε σωλήνα .

Εντολές με wild cards:
Η διαχείριση τους θα γίνει ως εξής .Κάθε φορά που διαβάζεται μια εντολή σε κάθε περίπτωση θα καλείται η συνάρτηση Filling_argv_and_wild_card_check που καλεί την glob()  ανεξάρτηττα αν υπάρχουν wild cards ή όχι . Συγκεκριμένα σε περίπτωση που υπάρχουν wild cards η συνάρτηση glob() ανάλογα το wild card θα βρεί ονόματα με 1. '?' ένα ίδιο γράμμα στην συγκεκριμένη θέση και 2. '*' για οποιοδήποτε αριθμό χαρακτήρων στην θέση αυτή (μπορέι να είναι μεγαλύτερος απο ένα ο αριθμός).
Οπότε η glob() θα δώσει τα αποτελέσματα της στο struct τύπου glob_t που θα φτιάξουμε και τα αποτλεέσματα αυτά θα τοποθετηθούν στην argv ως μέρος της εντολής .
Επομένως έστω ότι για παράδειγμα έχουμε στο directory τα αρχεία file1.txt και file2.txt και δίνουμε σαν εντολή ls file*txt τότε κάποια στιγμή θα καλεστεί η συνάρτηση Filling_argv_and_wild_card_check θα βρεί μέσω της glob ως αποτελέσματα τα file1.txt και file2.txt οπότε θα τα τοποθετήσει μέσω του λουπ στην argv . Οπότε στη νσυνέχεια θα καλεστεί η execvp με την argv να έχει τα εξής argv[0]=ls , argv[1]=file1.txt , argv[2]=file2.txt όπου και θα εμφανιστούν σε μορφή λίστας. Ομοίως για το wild card '?' .

Σήματα:
Για τα σήματα εφτιαξα σύο συναρτήσεις οι οποίες η μία ουσιαστικά θα λάζει τον τρόπο με τον οποίο θα γίνει ο χειρισμός του σήματος σταματήματος και διακοπής και συκγεκριμένα θα το αλάξουμε στο να αδιαφορούμε η signal_avoidance. Δηλαδή σε περίπτωση που καλεσθεί η συνάρτηση αυτή τότε κάθε φορά 
που δίνουμε ένα τέτοιου είδους σήμα θα αγνοηθεί . Μόνο σε περίπτωση που καλέσουμε την συνάρτηση signal_accept θα επαναφερθεί ο αρχικός τρόπος χειρισμού του σήματος δηλαδή αυτός που υπάρχει by default.
Aρχικά φτιάχνουμε δύο structs το in και το qu στα οποία θα δωθούν στα sa_handler μέρη τους τα τωρινά sa_handlers πριν καλεσθεί πρώτη φορά η signal_avoidance , δηλαδή οι by default ενέργειες που θα γίνουν όταν προκύψει σήμα σταματημού και διακοπής. Οπότε φυλλάσοντας τα εκεί έχουμε την δευνατότητα στην συνέχεια να επαναφέρουμε τον ίδιο χειρισμό για τα σήματα ξεχωριστά.
Στην signal_avoidance θα γίνουν τα παρακάτω : θέτουμε το term με τιμή 1 ώστε όταν καλεσθεί πρώτη φορά η συνάρτηση να προστεθεί και τρίτο όρισμα δηλαδή να δώσει στις in και qu τον παλιό χειρισμό που κάναμε στα σήματα αυτά  και όταν καλεστεί περισσότερες φορές να μην δωθεί τρίτο όρισμα διότι κρατήσαμε τον παλιό χειρισμό δεν χρειάζεται να τον ξανα κρατήσουμε .
Αρχικοποιούμε μέσω της memset την avoid ακ της δίνουμε τον νέο χειρισμό πυο θα είναι SIGN_IGN να αγνοηθεί δηλαδή το σήμα . 
Οπότε σε περίπτωση που μπαίνουμε πρώτη φορά στην συνάρτηση τότε να αλλάξει ο χειρισμός των σημάτων απο τον χειρισμό που έχουν by default στην αγνόηση τους και να δωθεί ο παλιός χειρισμός στις δομές in και qu . Σε περίπτωση που μπαίνουμε παραπάνω απο μία φορές τότε να γίνει το ίδιο απλώς να μην δωθεί στις δομές αυτές ο παλιός χειρισμός αφού αυτό έγινε ήδη .
Στην συνάρτηση signal_accept ουσιαστικά γίνεται επαναφορά του χειρισμού των σημάτων με τον by default τροπο . 
Η signal_avoidance καλέιται πριν την while στο αρχέιο mysh.c διότι θέλουμε να αγνοούνται εκεί τα σήματα γιατί θεωρείται ότι είμαστε στο κέλυφος και εκτελούμε εντολές . Σε περίπτωση που η εντολή που θα εκτελεστεί δεν βρίσκεται στο παρασκήνιο τότε επαναφέρουμε τα σήματα τότε να μπορέι να γίνεται η διακοπή ή το σταμάτημα όταν το δώσουμε.




